// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package internals

import (
	"context"
	"database/sql"
	"time"
)

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO employees (name, surname, email) 
VALUES ($1, $2, $3) 
RETURNING id, name, surname, email, created_at, updated_at
`

type CreateEmployeeParams struct {
	Name    string
	Surname string
	Email   string
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, createEmployee, arg.Name, arg.Surname, arg.Email)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Surname,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSale = `-- name: CreateSale :one
INSERT INTO sales (product_name, category, currency, price, sale_date, employee_id) 
VALUES ($1, $2, $3, $4, $5, $6) 
RETURNING id, product_name, category, currency, price, sale_date, employee_id, created_at, updated_at
`

type CreateSaleParams struct {
	ProductName string
	Category    string
	Currency    string
	Price       string
	SaleDate    time.Time
	EmployeeID  int32
}

func (q *Queries) CreateSale(ctx context.Context, arg CreateSaleParams) (Sale, error) {
	row := q.db.QueryRowContext(ctx, createSale,
		arg.ProductName,
		arg.Category,
		arg.Currency,
		arg.Price,
		arg.SaleDate,
		arg.EmployeeID,
	)
	var i Sale
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.Category,
		&i.Currency,
		&i.Price,
		&i.SaleDate,
		&i.EmployeeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEmployee = `-- name: DeleteEmployee :exec
DELETE FROM employees 
WHERE id = $1
`

func (q *Queries) DeleteEmployee(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteEmployee, id)
	return err
}

const deleteSale = `-- name: DeleteSale :exec
DELETE FROM sales 
WHERE id = $1
`

func (q *Queries) DeleteSale(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteSale, id)
	return err
}

const getEmployee = `-- name: GetEmployee :one
SELECT id, name, surname, email, created_at, updated_at 
FROM employees 
WHERE id = $1
`

func (q *Queries) GetEmployee(ctx context.Context, id int32) (Employee, error) {
	row := q.db.QueryRowContext(ctx, getEmployee, id)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Surname,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployeeByEmail = `-- name: GetEmployeeByEmail :one
SELECT id, name, surname, email, created_at, updated_at 
FROM employees 
WHERE email = $1
`

func (q *Queries) GetEmployeeByEmail(ctx context.Context, email string) (Employee, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeByEmail, email)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Surname,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployeeWithSales = `-- name: GetEmployeeWithSales :one
SELECT 
    e.id,
    e.name,
    e.surname,
    e.email,
    e.created_at,
    e.updated_at,
    COUNT(s.id) as total_sales,
    COALESCE(SUM(s.price), 0) as total_revenue
FROM employees e
LEFT JOIN sales s ON e.id = s.employee_id
WHERE e.id = $1
GROUP BY e.id, e.name, e.surname, e.email, e.created_at, e.updated_at
`

type GetEmployeeWithSalesRow struct {
	ID           int32
	Name         string
	Surname      string
	Email        string
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
	TotalSales   int64
	TotalRevenue interface{}
}

func (q *Queries) GetEmployeeWithSales(ctx context.Context, id int32) (GetEmployeeWithSalesRow, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeWithSales, id)
	var i GetEmployeeWithSalesRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Surname,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TotalSales,
		&i.TotalRevenue,
	)
	return i, err
}

const getEmployees = `-- name: GetEmployees :many
SELECT id, name, surname, email, created_at, updated_at 
FROM employees 
ORDER BY id
`

func (q *Queries) GetEmployees(ctx context.Context) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, getEmployees)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Surname,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSale = `-- name: GetSale :one
SELECT id, product_name, category, currency, price, sale_date, employee_id, created_at, updated_at 
FROM sales 
WHERE id = $1
`

func (q *Queries) GetSale(ctx context.Context, id int32) (Sale, error) {
	row := q.db.QueryRowContext(ctx, getSale, id)
	var i Sale
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.Category,
		&i.Currency,
		&i.Price,
		&i.SaleDate,
		&i.EmployeeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSales = `-- name: GetSales :many
SELECT id, product_name, category, currency, price, sale_date, employee_id, created_at, updated_at 
FROM sales 
ORDER BY sale_date DESC
`

func (q *Queries) GetSales(ctx context.Context) ([]Sale, error) {
	rows, err := q.db.QueryContext(ctx, getSales)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sale
	for rows.Next() {
		var i Sale
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.Category,
			&i.Currency,
			&i.Price,
			&i.SaleDate,
			&i.EmployeeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesByCategory = `-- name: GetSalesByCategory :many
SELECT id, product_name, category, currency, price, sale_date, employee_id, created_at, updated_at 
FROM sales 
WHERE category = $1 
ORDER BY sale_date DESC
`

func (q *Queries) GetSalesByCategory(ctx context.Context, category string) ([]Sale, error) {
	rows, err := q.db.QueryContext(ctx, getSalesByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sale
	for rows.Next() {
		var i Sale
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.Category,
			&i.Currency,
			&i.Price,
			&i.SaleDate,
			&i.EmployeeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesByDateRange = `-- name: GetSalesByDateRange :many
SELECT id, product_name, category, currency, price, sale_date, employee_id, created_at, updated_at 
FROM sales 
WHERE sale_date BETWEEN $1 AND $2 
ORDER BY sale_date DESC
`

type GetSalesByDateRangeParams struct {
	SaleDate   time.Time
	SaleDate_2 time.Time
}

func (q *Queries) GetSalesByDateRange(ctx context.Context, arg GetSalesByDateRangeParams) ([]Sale, error) {
	rows, err := q.db.QueryContext(ctx, getSalesByDateRange, arg.SaleDate, arg.SaleDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sale
	for rows.Next() {
		var i Sale
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.Category,
			&i.Currency,
			&i.Price,
			&i.SaleDate,
			&i.EmployeeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesByEmployee = `-- name: GetSalesByEmployee :many
SELECT id, product_name, category, currency, price, sale_date, employee_id, created_at, updated_at 
FROM sales 
WHERE employee_id = $1 
ORDER BY sale_date DESC
`

func (q *Queries) GetSalesByEmployee(ctx context.Context, employeeID int32) ([]Sale, error) {
	rows, err := q.db.QueryContext(ctx, getSalesByEmployee, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sale
	for rows.Next() {
		var i Sale
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.Category,
			&i.Currency,
			&i.Price,
			&i.SaleDate,
			&i.EmployeeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesStatsByEmployee = `-- name: GetSalesStatsByEmployee :many
SELECT 
    e.id,
    e.name,
    e.surname,
    e.email,
    COUNT(s.id) as total_sales,
    COALESCE(SUM(s.price), 0) as total_revenue,
    COALESCE(AVG(s.price), 0) as avg_sale_value
FROM employees e
LEFT JOIN sales s ON e.id = s.employee_id
GROUP BY e.id, e.name, e.surname, e.email
ORDER BY total_revenue DESC
`

type GetSalesStatsByEmployeeRow struct {
	ID           int32
	Name         string
	Surname      string
	Email        string
	TotalSales   int64
	TotalRevenue interface{}
	AvgSaleValue interface{}
}

func (q *Queries) GetSalesStatsByEmployee(ctx context.Context) ([]GetSalesStatsByEmployeeRow, error) {
	rows, err := q.db.QueryContext(ctx, getSalesStatsByEmployee)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesStatsByEmployeeRow
	for rows.Next() {
		var i GetSalesStatsByEmployeeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Surname,
			&i.Email,
			&i.TotalSales,
			&i.TotalRevenue,
			&i.AvgSaleValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmployee = `-- name: UpdateEmployee :one
UPDATE employees 
SET name = $2, surname = $3, email = $4, updated_at = CURRENT_TIMESTAMP 
WHERE id = $1 
RETURNING id, name, surname, email, created_at, updated_at
`

type UpdateEmployeeParams struct {
	ID      int32
	Name    string
	Surname string
	Email   string
}

func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, updateEmployee,
		arg.ID,
		arg.Name,
		arg.Surname,
		arg.Email,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Surname,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSale = `-- name: UpdateSale :one
UPDATE sales 
SET product_name = $2, category = $3, currency = $4, price = $5, sale_date = $6, employee_id = $7, updated_at = CURRENT_TIMESTAMP 
WHERE id = $1 
RETURNING id, product_name, category, currency, price, sale_date, employee_id, created_at, updated_at
`

type UpdateSaleParams struct {
	ID          int32
	ProductName string
	Category    string
	Currency    string
	Price       string
	SaleDate    time.Time
	EmployeeID  int32
}

func (q *Queries) UpdateSale(ctx context.Context, arg UpdateSaleParams) (Sale, error) {
	row := q.db.QueryRowContext(ctx, updateSale,
		arg.ID,
		arg.ProductName,
		arg.Category,
		arg.Currency,
		arg.Price,
		arg.SaleDate,
		arg.EmployeeID,
	)
	var i Sale
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.Category,
		&i.Currency,
		&i.Price,
		&i.SaleDate,
		&i.EmployeeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
